# Lapis

Kotlin-first codegen for Minecraft internals ‚Äî access the inaccessible, inject behavior, and write clean Kotlin. Enchant your mod with powerful extensions ‚Äî that‚Äôs the magic of Lapis!

[![Maven Central](https://img.shields.io/maven-central/v/io.github.recrafter/lapis.svg?label=Maven+Central&style=for-the-badge)](https://central.sonatype.com/artifact/io.github.recrafter/lapis) [![License: MIT](https://img.shields.io/static/v1?label=License&style=for-the-badge&message=MIT&color=yellow)](https://spdx.org/licenses/MIT)

---

## Installation

```kotlin
dependencies {
    // Add Lapis as a compileOnly dependency via KSP
    // Check latest version on Maven Central badge above ;)
    compileOnly(ksp("io.github.recrafter:lapis:$version"))
}

ksp {
    // Required: specify your mod ID
    arg("lapis.modId", "cool_mod")
}
```

‚ö†Ô∏è **Required**: You must provide your mod ID using `ksp.arg("lapis.modId", ...)`
This is used to namespace generated bridge methods and extensions.

## Overview

### üíé Kotlin Extensions ‚Äî The Heart of Lapis

Lapis turns your annotations into clean, type-safe, inline Kotlin APIs, tailored for Minecraft modding.
These Kotlin extensions are the primary developer-facing feature generated by Lapis.

| Feature | Annotation | Purpose |
|-------|------------|---------|
| Runtime patching | `@Patcher` | Inject custom logic and state into existing code |
| JVM access | `@Unlocker` | Access private/protected fields and methods |
| Kotlin aliases | `@Alias` | Rename & wrap accessible members for clarity |

---

## `@Patcher` ‚Äî Add State & Logic to Existing Classes

Use `@Patcher` to attach **custom state and behavior** to an existing class at runtime.  
This is ideal for scenarios where you need per-instance logic‚Äîlike tracking UI state, extending functionality, or hooking into lifecycle events.

Unlike `@Unlocker`, `@Patcher` doesn't just expose internals‚Äîit **adds new Kotlin logic directly to target instances** using Mixins, bridges, and auto-generated extension APIs.

---

### Example ‚Äî Track UI Overlay State

In this example, we patch `MinecraftClient` to track whether a custom overlay is shown, and reset it when a new screen opens.

```kotlin
@Patcher(target = MinecraftClient::class)
abstract class ClientPatch : Patch<MinecraftClient>() {

    private var isOverlayShown: Boolean = false

    fun openOverlay() {
        isOverlayShown = true
    }

    fun closeOverlay() {
        isOverlayShown = false
    }

    @Hook(method = "setScreen", at = At.HEAD)
    private fun onSetScreen(screen: Screen?) {
        if (screen != null) {
            closeOverlay()
        }
    }
}
```

This is an **abstract Kotlin class**, not a mixin. It behaves like a **component** that is automatically attached to each instance of the target class (`MinecraftClient`).

- You write regular Kotlin methods and fields.
- `@Hook` (WIP) can be used to intercept target methods.
- The `Patch<T>` superclass ensures the patch is scoped to the target instance.

---

### What Lapis Generates

Lapis transforms your patch into a fully integrated runtime extension, consisting of:

#### ‚úÖ Patch Implementation

```kotlin
class ClientPatch_Impl(
    override val target: MinecraftClient
) : ClientPatch()
```

This holds your patch state and methods.  
Each `MinecraftClient` instance will lazily attach its own `ClientPatch_Impl`.

#### ‚úÖ Java Mixin + Bridge

```java
@Mixin(MinecraftClient.class)
public class ClientPatch_Mixin implements ClientPatch_Bridge {

    private ClientPatch_Impl patch;

    private ClientPatch_Impl getOrInitPatch() {
        if (patch == null) {
            patch = new ClientPatch_Impl((MinecraftClient) (Object) this);
        }
        return patch;
    }

    public boolean modid_getOverlayOpen() {
        return getOrInitPatch().getOverlayOpen();
    }

    public void modid_setOverlayOpen(boolean newValue) {
        getOrInitPatch().setOverlayOpen(newValue);
    }

    public void modid_openOverlay() {
        getOrInitPatch().openOverlay();
    }

    public void modid_closeOverlay() {
        getOrInitPatch().closeOverlay();
    }
}
```

The mixin is injected into the target class.  
It holds the patch instance and forwards calls to it.

#### ‚úÖ Kotlin Extensions

```kotlin
inline var MinecraftClient.overlayOpen: Boolean
inline fun MinecraftClient.openOverlay()
inline fun MinecraftClient.closeOverlay()
```

You can now write:

```kotlin
client.overlayOpen = true
client.openOverlay()
```

‚Ä¶with no knowledge of the patch class, bridge, or mixin.  
It's just Kotlin‚Äîand it's type-safe, inline, and zero-cost.

---

### Under the Hood ‚Äî How It Works

1. **You write** a patch class that extends `Patch<T>`.
2. **Lapis generates**:
    - A Kotlin `*_Impl` class (your patch logic)
    - A Java Mixin class injected into the target
    - A `*_Bridge` interface to define exposed members
    - Kotlin extensions that forward through the bridge
3. **Each target instance** (e.g., `MinecraftClient`) lazily attaches a patch instance.
4. **Extensions** resolve the correct patch via the mixin bridge and call its methods.

---

### Notes

- `@Hook` support is still **WIP**, but the structure is already in place.
- Patch members must be **non-private** to be accessible through extensions.
- You can use properties, methods, and even lifecycle handlers‚Äîeverything behaves like normal Kotlin.

---

### Summary

| Feature                | Purpose                                                |
|-----------------------|--------------------------------------------------------|
| `@Patcher`            | Define new behavior or state for existing classes      |
| `*_Impl` class        | Your actual patch logic, in idiomatic Kotlin           |
| Java Mixin + Bridge   | Inject patch and expose it to Kotlin extensions        |
| Kotlin extensions     | Clean, inline APIs with no reflection or boilerplate   |
---

## `@Unlocker` ‚Äî Open Private & Protected Members with Clean Kotlin

Use `@Unlocker` when you need access to private or protected fields, methods, or constructors in Minecraft classes.  
Lapis generates all the necessary Mixin boilerplate and exposes everything through **safe, inline Kotlin extensions**.

This eliminates the need for reflection or unsafe casting, while keeping your code clean and idiomatic.

---

### Example ‚Äî Unlock Hidden APIs

This unlocker exposes:

- a **private field** (`window`),
- a **private method** (`doTick()`),
- a **private constructor**.

```kotlin
@Unlocker(target = MinecraftClient::class, widener = "net.minecraft.client.MinecraftClient")
interface MinecraftClientUnlocker {

    @UnlockField
    val window: Window

    @UnlockMethod
    fun doTick()

    @UnlockConstructor("<init>")
    fun create()
}
```

Each member is abstract and annotated to indicate what it unlocks.  
Lapis automatically handles the Mixin wiring and Kotlin API generation.

---

### What Lapis Generates

#### ‚úÖ Java Mixin

This interface is injected at runtime using Sponge Mixin.

```java
@Mixin(MinecraftClient.class)
public interface MinecraftClient_Mixin {
    @Accessor("window") Window getWindow();
    @Invoker("doTick") void invokeDoTick();
    @Invoker("<init>") static MinecraftClient create();
}
```

These accessors/invokers provide raw JVM access to hidden fields, methods, and constructors.

---

#### ‚úÖ Kotlin Extensions

Lapis wraps the accessors with inline Kotlin extension functions:

```kotlin
inline val MinecraftClient.window: Window
inline fun MinecraftClient.doTick()
```

These are safe and feel like native APIs‚Äîno need for reflection or casting.

---

#### ‚úÖ Factory Object (for Static Access & Constructors)

Static methods and constructors are accessed via a generated Kotlin object:

```kotlin
object MinecraftClientKFactory {
    val window: Window
    fun create(): MinecraftClient
}
```

This ensures clean separation of static vs instance APIs.

You can now write:

```kotlin
val client = MinecraftClientKFactory.create()
client.doTick()
client.window
```

Just like you would with regular public APIs.

---

### Wideners ‚Äî Making Classes Accessible

When the target class is not public, you must provide a `widener` string.  
Lapis uses this to generate entries in:

```
META-INF/lapis/wideners.txt
```

Nested unlockers combine wideners automatically:

```kotlin
@Unlocker(widener = "client")
interface ClientUnlocker {
    @Unlocker(widener = ".settings")
    interface SettingsUnlocker
}
```

‚û°Ô∏è Result: `client$settings`

---

### Summary

| Feature                     | Purpose                                              |
|----------------------------|------------------------------------------------------|
| `@UnlockField`             | Exposes private or protected fields                 |
| `@UnlockMethod`            | Exposes private or protected methods                |
| `@UnlockConstructor`       | Exposes hidden constructors                         |
| Kotlin extensions          | Inline, type-safe access to unlocked members         |
| Factory objects            | Clean APIs for static fields and constructors        |
| `widener`                  | Enables access to internal or package-private classes |

Lapis turns internals into idiomatic, safe, Kotlin-first APIs‚Äî**with no reflection and no boilerplate.**

---

## `@Alias` ‚Äî Clean Kotlin Wrappers for Existing Public APIs

Use `@Alias` when the target class is **already accessible**, and you want to wrap or rename its members using clean, idiomatic Kotlin.

Unlike `@Unlocker`, `@Alias` does **not** use Mixins.  
It simply generates **inline Kotlin extension functions and properties** that redirect to public fields and methods, making your code more readable and maintainable.

---

### Example ‚Äî Renaming Public APIs

Here we define a new name for a public field and method:

```kotlin
@Alias(target = MinecraftClient::class)
interface MinecraftClientAlias {

    @FieldAlias("window")
    val mainWindow: Window

    @MethodAlias("setScreen")
    fun openScreen(screen: Screen)
}
```

This doesn‚Äôt change behavior‚Äîit just gives you a more expressive Kotlin-facing API.

---

### Rules & Requirements

To ensure predictable code generation, the following rules apply:

- The annotated type **must be an interface**
- It must be a **top-level (root) interface**
- Each property must use `@FieldAlias`
- Each function must use `@MethodAlias`
- All members must be **abstract**
- The target class must be **already visible** (i.e., no `@Unlocker` needed)

---

### ‚úÖ What Lapis Generates

Given the example above, Lapis generates the following in:

```
MinecraftClientExt.kt
```

```kotlin
inline val MinecraftClient.mainWindow: Window
inline fun MinecraftClient.openScreen(screen: Screen)
```

These extensions redirect to the original member (`window`, `setScreen`) but use your alias names (`mainWindow`, `openScreen`).

They‚Äôre **inline**, **type-safe**, and require no reflection or runtime overhead.

---

### Optional: `typeAlias` Support

If you specify the `typeAlias` parameter on `@Alias`, Lapis will also generate a Kotlin `typealias` for the target class:

```kotlin
typealias GameClient = MinecraftClient
```

This is useful when you want to abstract implementation details or unify references across modules.

---

### Summary

| Use Case                       | Use               |
|--------------------------------|--------------------|
| Rename or wrap public members  | `@Alias`           |
| Access private or protected    | `@Unlocker`        |
| Add new state and behavior     | `@Patcher`         |

Lapis gives you ergonomic, Kotlin-first access to existing APIs‚Äî**no Mixins, no reflection, no mess.**

---

## License

This project is licensed under the [MIT License](https://spdx.org/licenses/MIT).
